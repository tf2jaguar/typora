[toc]

## 启动**MySQL**服务器程序 **1.3.1 UNIX**里启动服务器程序

在类 UNIX 系统中用来启动 MySQL 服务器程序的可执行文件有很多，大多在 MySQL 安装目录的 bin 目录下，我们 一起来瞅瞅。

**mysqld**

mysqld 这个可执行文件就代表着 MySQL 服务器程序，运行这个可执行文件就可以直接启动一个服务器进程。但 这个命令不常用，我们继续往下看更牛逼的启动命令。

**mysqld_safe**

mysqld_safe 是一个启动脚本，它会间接的调用 mysqld ，而且还顺便启动了另外一个监控进程，这个监控进程 在服务器进程挂了的时候，可以帮助重启它。另外，使用 mysqld_safe 启动服务器程序时，它会将服务器程序的 出错信息和其他诊断信息重定向到某个文件中，产生出错日志，这样可以方便我们找出发生错误的原因。

**mysql.server**

mysql.server 也是一个启动脚本，它会间接的调用 mysqld_safe ，在调用 mysql.server 时在后边指定 start 参数就可以启动服务器程序了，就像这样:

  mysql.server start

需要注意的是，这个 **mysql.server** 文件其实是一个链接文件，它的实际文件是 **../support-files/mysql.server**。 我使用的 macOS 操作系统会帮我们在 bin 目录下自动创建一个指向实际文件的链接文件，如果你的操作系统没有 帮你自动创建这个链接文件，那就自己创建一个呗~ 别告诉我你不会创建链接文件，上网搜搜呗~

另外，我们还可以使用 mysql.server 命令来关闭正在运行的服务器程序，只要把 start 参数换成 stop 就好 了:

  mysql.server stop

**mysqld_multi**

其实我们一台计算机上也可以运行多个服务器实例，也就是运行多个 MySQL 服务器进程。 mysql_multi 可执行文 件可以对每一个服务器进程的启动或停止进行监控。

## **Windows**里启动服务器程序

Windows 里没有像类 UNIX 系统中那么多的启动脚本，但是也提供了手动启动和以服务的形式启动这两种方式，

下边我们详细看。

**mysqld**

同样的，在 MySQL 安装目录下的 bin 目录下有一个 mysqld 可执行文件，在命令行里输入 mysqld ，或者直接双 击运行它就算启动了 MySQL 服务器程序了。

**1.3.2.2** 以服务的方式运行服务器程序

首先看看啥是个 Windows 服务?如果无论是谁正在使用这台计算机，我们都需要长时间的运行某个程序，而且 需要在计算机启动的时候便启动它，一般我们都会把它注册为一个 Windows 服务 ，操作系统会帮我们管理它。 把某个程序注册为 Windows 服务的方式挺简单，如下:

"完整的可执行文件路径" --install [-manual] [服务名]

其中的 -manual 可以省略，加上它的话表示在 Windows 系统启动的时候不自动启动该服务，否则会自动启动。

服务名 也可以省略，默认的服务名就是 MySQL 。比如我的 Windows 计算机上 mysqld 的完整路径是: C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld

所以如果我们想把它注册为服务的话可以在命令行里这么写:

"C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqld" --install

在把 mysqld 注册为 Windows 服务之后，我们就可以通过下边这个命令来启动 MySQL 服务器程序了:

net start MySQL

当然，如果你喜欢图形界面的话，你可以通过 Windows 的服务管理器通过用鼠标点点点的方式来启动和停止服务

(作为一个程序猿，还是用黑框框吧~)。 关闭这个服务也非常简单，只要把上边的 start 换成 stop 就行了，就像这样:

  net stop MySQL

## 服务器处理客户端请求

其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是:客户端进程向服务器进程发 送一段文本(MySQL语句)，服务器进程处理后再向客户端进程发送一段文本(处理结果)

<img src="pic/mysql是怎么运行的-笔记/image-20220302091246776.png" alt="image-20220302091246776" style="zoom:35%;" />

客户端进程可以采用我们上边介绍的 TCP/IP 、 命名管道或共享内存 、 Unix域套接字 这几种方式之一来与服务 器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个 客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而 是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频 繁创建和销毁线程的效果，从而节省开销。



如果两个查询请求在任何字符上的不同(例如:空格、注释、大小写)，都 会导致缓存不会命中。另外，如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如 mysql 、information_schema、 performance_schema 数据库中的表，那这个请求就不会被缓存。



不过既然是缓存，那就有它缓存失效的时候。MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数 据被修改，如对该表使用了 INSERT 、 UPDATE 、 DELETE 、 TRUNCATE TABLE 、 ALTER TABLE 、 DROP TABLE 或

DROP DATABASE 语句，那使用该表的所有高速缓存查询都将变为无效并从高速缓存中删除!

## 常用存储引擎

<img src="pic/mysql是怎么运行的-笔记/image-20220304090948840.png" alt="image-20220304090948840" style="zoom:40%;" />

这么多我们怎么挑啊，哈哈，你多虑了，其实我们最常用的就是 InnoDB 和 MyISAM ，有时会提一下 Memory 。其 中 InnoDB 是 MySQL 默认的存储引擎，我们之后会详细唠叨这个存储引擎的各种功能，现在先看一下一些存储引 擎对于某些功能的支持情况

<img src="pic/mysql是怎么运行的-笔记/image-20220304171109772.png" alt="image-20220304171109772" style="zoom:43%;" />

<img src="pic/mysql是怎么运行的-笔记/image-20220304171131761.png" alt="image-20220304171131761" style="zoom:43%;" />

##  一些重要的字符集

- ASCII 字符集 共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式:

  ```
  'L' -> 01001100(十六进制:0x4C，十进制:76)
  'M' -> 01001101(十六进制:0x4D，十进制:77) 
  ```

- ISO 8859-1 字符集 共收录256个字符，是在 ASCII 字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以 使用1个字节来进行编码。这个字符集也有一个别名 latin1 。

- GB2312 字符集 收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个， 其他文字符号682个。同时这种字符集又兼容 ASCII 字符集，所以在编码方式上显得有些奇怪:

- - 如果该字符在 ASCII 字符集中，则采用1字节编码。 
  - 否则采用2字节编码。

这种表示一个字符需要的字节数可能不同的编码方式称为 变长编码方式 。比方说字符串 '爱u' ，其 中 '爱' 需要用2个字节进行编码，编码后的十六进制表示为 0xCED2 ， 'u' 需要用1个字节进行编码， 编码后的十六进制表示为 0x75 ，所以拼合起来就是 0xCED275 。

> 小贴士: 我们怎么区分某个字节代表一个单独的字符还是代表某个字符的一部分呢?别忘了`ASCII`字 符集只收录128个字符，使用0~127就可以表示全部字符，所以如果某个字节是在0~127之内 的，就意味着一个字节代表一个单独的字符，否则就是两个字节代表一个单独的字符。

- GBK 字符集 GBK 字符集只是在收录字符范围上对 GB2312 字符集作了扩充，编码方式上兼容 GB2312 。

- utf8 字符集 收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容 ASCII 字符集，采用变长编码方式，编码一个字符需要使用1~4个字节，比方说这样: 

  ```
  'L' -> 01001100(十六进制:0x4C)
  '啊' -> 111001011001010110001010(十六进制:0xE5958A)
  ```

> 小贴士: 其实准确的说，utf8只是Unicode字符集的一种编码方案，Unicode字符集可以采用utf8、utf1 6、utf32这几种编码方案，utf8使用1~4个字节编码一个字符，utf16使用2个或4个字节编码一个 字符，utf32使用4个字节编码一个字符。更详细的Unicode和其编码方案的知识不是本书的重点， 大家上网查查哈~

MySQL中并不区分字符集和编码方案的概念，所以后边唠叨的时候把utf8、utf16、utf32都当作 一种字符集对待。

对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字 '我' 来说， ASCII 字符集中根本没有收 录这个字符， utf8 和 gb2312 字符集对汉字 我 的编码方式如下:

```
utf8编码:111001101000100010010001 (3个字节，十六进制表示是:0xE68891) 
gb2312编码:1100111011010010 (2个字节，十六进制表示是:0xCED2)
```

### **MySQL**中的**utf8**和**utf8mb4**

我们上边说 utf8 字符集表示一个字符需要使用1~4个字节，但是我们常用的一些字符使用1~3个字节就可以表 示了。而在 MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计

MySQL 的大叔偷偷的定义了两个概念:

- utf8mb3 :阉割过的 utf8 字符集，只使用1~3个字节表示字符。

- utf8mb4 :正宗的 utf8 字符集，使用1~4个字节表示字符。

有一点需要大家十分的注意，在 MySQL 中 utf8 是 utf8mb3 的别名，所以之后在 MySQL 中提到 utf8 就意味着使 用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请 使用 utf8mb4 。

### 比较规则的查看

查看 MySQL 中支持的比较规则的命令如下:

SHOW COLLATION [LIKE 匹配的模式];

我们前边说过一种字符集可能对应着若干种比较规则， MySQL 支持的字符集就已经非常多了，所以支持的比较规 则更多，我们先只查看一下 utf8 字符集下的比较规则:

```
mysql> show COLLATION like 'utf8\_%';
+--------------------------+---------+-----+---------+----------+---------+
| Collation                | Charset | Id  | Default | Compiled | Sortlen |
+--------------------------+---------+-----+---------+----------+---------+
| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |
| utf8_bin                 | utf8    |  83 |         | Yes      |       1 |
| utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 |
| utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 |
| utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 |
| utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 |
| utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 |
| utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 |
| utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 |
| utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 |
| utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 |
| utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 |
| utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 |
| utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 |
| utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 |
| utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 |
| utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 |
| utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 |
| utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 |
| utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 |
| utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 |
| utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 |
| utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 |
| utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 |
| utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 |
| utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 |
| utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |
+--------------------------+---------+-----+---------+----------+---------+
27 rows in set (0.00 sec)
```

这些比较规则的命名还挺有规律的，具体规律如下:

- 比较规则名称以与其关联的字符集的名称开头。如上图的查询结果的比较规则名称都是以 utf8 开头的。 
- 后边紧跟着该比较规则主要作用于哪种语言，比如 utf8_polish_ci 表示以波兰语的规则比较，utf8_spanish_ci 是以西班牙语的规则比较， utf8_general_ci 是一种通用的比较规则。 
- 名称后缀意味着该比较规则是否区分语言中的重音、大小写啥的，具体可以用的值如下:

| 后缀 | 英文释义 | 描述 |
| ---- | -------- | ---- |
| _ai | accent insensitive |不区分重音| 
| _as | accent sensitive |区分重 音| 
| _ci | case insensitive |不区分大小写| 
| _cs | case sensitive |区分大小写| 
| _bin | binary |以二进制 方式比较|

比如 utf8_general_ci 这个比较规则是以 ci 结尾的，说明不区分大小写。

每种字符集对应若干种比较规则，每种字符集都有一种默认的比较规则， SHOW COLLATION 的返回结果中的 Default 列的值为 YES 的就是该字符集的默认比较规则，比方说 utf8 字符集默认的比较规则就是 utf8_general_ci 。

### MySQL有四个级别的字符集和比较规则 

- 服务器级别

> character_set_server 表示服务器级别的字符集， collation_server 表示服务器级别的比较规则。

- 数据库级别 

> 创建和修改数据库时可以指定字符集和比较规则:
>
> ​	CREATE DATABASE 数据库名
>
> ​			[[DEFAULT] CHARACTER SET 字符集名称] [[DEFAULT] COLLATE 比较规则名称];

> ALTER DATABASE 数据库名
>
> ​			[[DEFAULT] CHARACTER SET 字符集名称] [[DEFAULT] COLLATE 比较规则名称];

character_set_database 表示当前数据库的字符集， collation_database 表示当前默认数据库的比较 规则，这两个系统变量是只读的，不能修改。如果没有指定当前默认数据库，则变量与相应的服务器级 系统变量具有相同的值。

- 表级别

> 创建和修改表的时候指定表的字符集和比较规则:
>
> ​	CREATE TABLE 表名 (列的信息)
>
> ​			[[DEFAULT] CHARACTER SET 字符集名称]  [COLLATE 比较规则名称]];

>  ALTER TABLE 表名
>
> ​			[[DEFAULT] CHARACTER SET 字符集名称]  [COLLATE 比较规则名称];

- 列级别

> 创建和修改列定义的时候可以指定该列的字符集和比较规则:
>
> CREATE TABLE 表名(
>
> ​	列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称], 
>
> ​	其他列...
>
> );
>
> ALTER TABLE 表名 MODIFY 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规 则名称];

## **InnoDB**记录结构

InnoDB 采取的方式是:将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小 一般为 **16** KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB 内容刷新到磁盘中。



我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 **行格式 或者 记录格式 **。 设计 InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、Dynamic 和 Compressed 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理 上大体都是相同的。



### compact 行格式

<img src="pic/mysql是怎么运行的-笔记/image-20220304114204074.png" alt="image-20220304114204074" style="zoom:30%;" />

在 Compact 行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长 字段长度列表，各变长字段数据占用的字节数 **按照列的顺序逆序存放**

```
mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
    
mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'),
     ('eeee', 'fff', NULL, NULL);
    Query OK, 2 rows affected (0.02 sec)
    Records: 2  Duplicates: 0  Warnings: 0
```

```
mysql> SELECT * FROM record_format_demo;
    +------+-----+------+------+
    | c1   | c2  | c3   | c4   |
    +------+-----+------+------+
    | aaaa | bbb | cc   | d    |
    | eeee | fff | NULL | NULL |
    +------+-----+------+------+
    2 rows in set (0.00 sec)
```

#### 变长字段长度列表

由于第一行记录中 c1 、 c2 、 c4 列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可 以表示，但是如果变长列的内容占用的字节数比较多，**可能就需要用2个字节来表示**。具体用1个还是2个字节来 表示真实数据占用的字节数， InnoDB 有它的一套规则，我们首先声明一下 W 、 M 和 L 的意思:

1. 假设某个字符集中表示一个字符最多需要使用的字节数为 W ，也就是使用 SHOW CHARSET 语句的结果中的 Maxlen 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是 1。

2. 对于变长类型 **VARCHAR(M)** 来说，这种类型表示能存储最多 M 个字符(注意是字符不是字节)，所以这个类 型能表示的字符串最多占用的字节数就是 M×W 。

3. 假设它实际存储的字符串占用的字节数是 L 。 所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样:

如果 M×W <= 255 ，那么使用1个字节来表示真正字符串占用的字节数。 也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。

如果 M×W > 255 ，则分为两种情况:

如果 L <= 127 ，则用1个字节来表示真正字符串占用的字节数。 如果 L > 127 ，则用2个字节来表示真正字符串占用的字节数。

> InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢? 
>
> 设计InnoDB的大叔使用该字节的第一个二进制位作为标志位:如果该字节的第一个位为0，那 该字节就是一个单独的字段长度(使用一个字节表示不大于127的二进制的第一个位都为0)， 如果该字节的第一个位为1，那该字节就是半个字段长度。

> 对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个 页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中(我们后边会唠叨)，在变 长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

总结一下就是说: 

- **如果该可变字段允许存储的最大字节数( M×W )超过255字节并且真实存储的字节数( L ) 超过127字节，则使用2个字节，否则使用1个字节。**
- 变长字段长度列表中只存储值为 **非NULL** 的列内容占用的长度，值为 **NULL** 的列的长度 是不储存的
- 并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话， 这一部分就不需要有

#### NULL值列表

如果表中没有允许存储 **NULL** 的列，则 NULL值列表 也不存在了，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序 **逆序** 排列

- 二进制位的值为 1 时，代表该列的值为 NULL 
- 二进制位的值为 0 时，代表该列的值不为 NULL 

MySQL 规定 NULL值列表 必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节 的高位补 0 

#### 记录头信息

除了 变长字段长度列表 、 NULL值列表 之外，还有一个用于描述记录的 记录头信息 ，它是由固定的 5 个字节组 成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思

<img src="pic/mysql是怎么运行的-笔记/image-20220304115429640.png" alt="image-20220304115429640" style="zoom:45%;" />

<img src="pic/mysql是怎么运行的-笔记/image-20220304115655601.png" alt="image-20220304115655601" style="zoom:35%;" />

#### 记录的真实数据

对于 record_format_demo 表来说， 记录的真实数据 除了 c1 、 c2 、 c3 、 c4 这几个我们自己定义的列的数据 以外， MySQL 会为每个记录默认的添加一些列(也称为 隐藏列 )，具体的列如下

<img src="pic/mysql是怎么运行的-笔记/image-20220304115517822.png" alt="image-20220304115517822" style="zoom:45%;" />

实际上这几个列的真正名称其实是:DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row _id、transaction_id和roll_pointer

**这里需要提一下 InnoDB 表对主键的生成策略:**

优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 Unique 键作为主键，如果表中连 Unique 键都没有定义的话，则 InnoDB 会为表默认添加一个名为row_id 的隐藏列作为主键

#### char(m)列的存储格式

对于 ***CHAR(M)\*** 类型的列来说：

- 当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表
- 如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表。

char 如果采用定长字符集，则除真实数据以外的字节的统统都用空格字符填充，空格字符在 ascii 字符集的表示是 0x20 

另外有一点还需要注意，变长字符集的 CHAR(M) 类型的列要求至少占用 M 个字节，而 VARCHAR(M) 却没有这个要 求。比方说对于使用 utf8 字符集的 CHAR(10) 的列来说，该列存储的数据字节长度的范围是10~30个字节。即 使我们向该列中存储一个空字符串也会占用 10 个字节，这是怕将来更新该列的值的字节长度大于原有值的字节 长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有 的记录空间成为所谓的碎片。

### Redundant行格式

Redundant 行格式是 MySQL5.0 之前用的一种行格式，也就是说它已经非常老了

<img src="pic/mysql是怎么运行的-笔记/image-20220304120241151.png" alt="image-20220304120241151" style="zoom:30%;" />

针对同一段数据

```
mysql> SELECT * FROM record_format_demo;
    +------+-----+------+------+
    | c1   | c2  | c3   | c4   |
    +------+-----+------+------+
    | aaaa | bbb | cc   | d    |
    | eeee | fff | NULL | NULL |
    +------+-----+------+------+
    2 rows in set (0.00 sec)
```



Redundant 格式

<img src="pic/mysql是怎么运行的-笔记/image-20220304120312624.png" alt="image-20220304120312624" style="zoom:40%;" />

compact 格式

<img src="pic/mysql是怎么运行的-笔记/image-20220304120338554.png" alt="image-20220304120338554" style="zoom:40%;" />

下边我们从各个方面看一下 Redundant 行格式有什么不同的地方:

- 字段长度偏移列表

注意 Compact 行格式的开头是 变长字段长度列表 ，而 Redundant 行格式的开头是 字段长度偏移列表 ，与 变长字段长度列表 有两处不同:

- - 没有了变长两个字，意味着 Redundant 行格式会把该条记录中所有列(包括 隐藏列 )的长度信息都按 照逆序存储到 字段长度偏移列表 。
  - 多了个偏移两个字，这意味着计算列值长度的方式不像 Compact 行格式那么直观，它是采用两个相邻数 值的差值来计算各个列值的长度。

比如第一条记录的 字段长度偏移列表 就是: 

​		25 24 1A 17 13 0C 06

  因为它是逆序排放的，所以按照列的顺序排列就是:

​       06 0C 13 17 1A 24 25

按照两个相邻数值的差值来计算各个列值的长度的意思就是: 

> 第一列(`row_id`)的长度就是 0x06个字节，也就是6个字节。 
>
> 第二列(`transaction_id`)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。 
>
> 第三列(`roll_pointer`)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。 
>
> 第四列(`c1`)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。 
>
> 第五列(`c2`)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。 
>
> 第六列(`c3`)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。
>
> 第七列(`c4`)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。

- 记录头信息

Redundant 行格式的记录头信息占用 6 字节， 48 个二进制位，这些二进制位代表的意思如下:

|      名称       | 大小(单位:bit) |                             描述                             |
| :-------------: | :------------: | :----------------------------------------------------------: |
|     预留位1     |       1        |                           没有使用                           |
|     预留位2     |       1        |                           没有使用                           |
|   delete_mask   |       1        |                     标记该记录是否被删除                     |
|  min_rec_mask   |       1        |       B+树的每层非叶子节点中的最小记录都会添 加该标记        |
|     n_owned     |       4        |                   表示当前记录拥有的记录数                   |
|     heap_no     |       13       |                表示当前记录在页面堆的位置信息                |
|     n_field     |       10       |                      表示记录中列的数量                      |
| 1byte_offs_flag |       1        | 标记字段长度偏移列表中每个列对应的偏移量是 使用1字节还是2字节表示的 |
|   next_record   |       16       |                   表示下一条记录的相对位置                   |

第一条记录中的头信息是:

   00 00 10 0F 00 BC

根据这六个字节可以计算出各个属性的值，如下:

> 预留位1:0x00 
>
> 预留位2:0x00 
>
> delete_mask: 0x00 
>
> min_rec_mask: 0x00 
>
> n_owned: 0x00 
>
> heap_no: 0x02 
>
> n_field: 0x07 
>
> 1byte_offs_flag: 0x01 
>
> next_record:0xBC

与 Compact 行格式的记录头信息对比来看，有两处不同:

- Redundant 行格式多了 n_field 和 1byte_offs_flag 这两个属性。 

- Redundant 行格式没有 record_type 这个属性。

  

- 1byte_offs_flag 的值是怎么选择的

字段长度偏移列表 实质上是存储每个列中的值占用的空间在 记录的真实数据 处结束的位置，还是拿record_format_demo 第一条记录为例， 0x06 代表第一个列在 记录的真实数据 第6个字节处结束， 0x0C 代 表第二个列在 记录的真实数据 第12个字节处结束， 0x13 代表第三个列在 记录的真实数据 第19个字节处结 束，等等等等，最后一个列对应的偏移量值为 0x25 ，也就意味着最后一个列在 记录的真实数据 第37个字 节处结束，也就意味着整条记录的 真实数据 实际上占用 37 个字节。

我们前边说过每个列对应的偏移量可以占用1个字节或者2个字节来存储，那到底什么时候用1个字节，什么 时候用2个字节呢?其实是根据该条 Redundant 行格式 记录的真实数据 占用的总大小来判断的:

- 当记录的真实数据占用的字节数不大于127(十六进制 0x7F ，二进制 01111111 )时，每个列对应的偏 移量占用1个字节。
- 小贴士: 如果整个记录的真实数据占用的存储空间都不大于127个字节，那么每个列对应的偏移量值肯 定也就不大于127，也就可以使用1个字节来表示喽。
- 当记录的真实数据占用的字节数大于127，但不大于32767(十六进制 0x7FFF ，二进制 0111111111111111 )时，每个列对应的偏移量占用2个字节。
- 有没有记录的真实数据大于32767的情况呢?有，不过此时的记录已经存放到了溢出页中，在本页中只 保留前 768 个字节和20个字节的溢出页面地址(当然这20个字节中还记录了一些别的信息)。因为 字 段长度偏移列表 处只需要记录每个列在本页面中的偏移就好了，所以每个列使用2个字节来存储偏移量 就够了。

大家可以看出来，设计 Redundant 行格式的大叔还是比较简单粗暴的，直接使用整个 记录的真实数据 长度来决定使用1个字节还是2个字节存储列对应的偏移量。只要整条记录的真实数据占用的存储空间大 小大于127，即使第一个列的值占用存储空间小于127，那对不起，也需要使用2个字节来表示该列对应 的偏移量。简单粗暴，就是这么简单粗暴(所以这种行格式有些过时了~)。

小贴士: 大家有没有疑惑，一个字节能表示的范围是0~255，为啥在记录的真实数据占用的存储空间大 于127时就采用2个字节表示各个列的偏移量呢?稍安勿躁，后边马上揭晓。

为了在解析记录时知道每个列的偏移量是使用1个字节还是2个字节表示的，设计 Redundant 行格式的大 叔特意在 记录头信息 里放置了一个称之为 1byte_offs_flag 的属性: 

- 当它的值为1时，表明使用1个字节存储。

- 当它的值为0时，表明使用2个字节存储。
- Redundant 行格式中 NULL 值的处理

因为 Redundant 行格式并没有 NULL值列表 ，所以设计 Redundant 行格式的大叔在 字段长度偏移列表 中的 各个列对应的偏移量处做了一些特殊处理 —— 将列对应的偏移量值的第一个比特位作为是否为 NULL 的依 据，该比特位也可以被称之为 NULL比特位 。也就是说在解析一条记录的某个列时，首先看一下该列对应的 偏移量的 NULL比特位 是不是为 1 ，如果为 1 ，那么该列的值就是 NULL ，否则不是 NULL 。

这也就解释了上边介绍为什么只要记录的真实数据大于127(十六进制 0x7F ，二进制 01111111 )时，就采 用2个字节来表示一个列对应的偏移量，主要是第一个比特位是所谓的 NULL比特位 ，用来标记该列的值是否 为 NULL 。

但是还有一点要注意，对于值为 NULL 的列来说，该列的类型是否为定长类型决定了 NULL 值的实际存储方 式，我们接下来分析一下 record_format_demo 表的第二条记录，它对应的 字段长度偏移列表 如下:

   A4 A4 1A 17 13 0C 06

按照列的顺序排放就是:

   06 0C 13 17 1A A4 A4

我们分情况看一下:

- 如果存储 NULL 值的字段是定长类型的，比方说 CHAR(M) 数据类型的，则 NULL 值也将占用记录的真实 数据部分，并把该字段对应的数据使用 0x00 字节填充。

如图第二条记录的 c3 列的值是 NULL ，而 c3 列的类型是 CHAR(10) ，占用记录的真实数据部分10字 节，所以我们看到在 Redundant 行格式中使用 0x00000000000000000000 来表示 NULL 值。

另外， c3 列对应的偏移量为 0xA4 ，它对应的二进制实际是: 10100100 ，可以看到最高位为 1 ，意味 着该列的值是 NULL 。将最高位去掉后的值变成了 0100100 ，对应的十进制值为 36 ，而 c2 列对应的偏 移量为 0x1A ，也就是十进制的 26 。 36 - 26 = 10 ，也就是说最终 c3 列占用的存储空间为10个字 节。

- 如果该存储 NULL 值的字段是变长数据类型的，则不在 记录的真实数据 处占用任何存储空间。

比如 record_format_demo 表的 c4 列是 VARCHAR(10) 类型的， VARCHAR(10) 是一个变长数据类型， c4 列对应的偏移量为 0xA4 ，与 c3 列对应的偏移量相同，这也就意味着它的值也为 NULL ，将 0xA4的最高位去掉后对应的十进制值也是 36 ， 36 - 36 = 0 ，也就意味着 c4 列本身不占用任何 记录的实 际数据 处的空间。

除了以上的几点之外， Redundant 行格式和 Compact 行格式还是大致相同的。

#### char(m)列的存储格式

我们知道 Compact 行格式在 CHAR(M) 类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况， 而在 Redundant 行格式中十分干脆，不管该列使用的字符集是啥，只要是使用 CHAR(M) 类型，占用的真实数据空 间就是该字符集表示一个字符最多需要的字节数和 M 的乘积。比方说使用 utf8 字符集的 CHAR(10) 类型的列占 用的真实数据空间始终为 30 个字节，使用 gbk 字符集的 CHAR(10) 类型的列占用的真实数据空间始终为 20 个字 节。由此可以看出来，使用 Redundant 行格式的 CHAR(M) 类型的列是不会产生碎片的。

### 行溢出数据

#### VARCHAR(M) 最多能存储的数据

我们知道对于mysql一行有65535字节限制，则 VARCHAR(M) 类型的列最多可以占用 65535 个字节。其中的 M 代表该类型最多存储的字符数量，如 果我们使用 ascii 字符集的话，一个字符就代表一个字节

这个 65535 个字节除了列本身的数据之外，还包括一些 其他的数据( storage overhead )，比如说我们为了存储一个 VARCHAR(M) 类型的列，其实需要占用3部分存储 空间:

- 真实数据
- 真实数据占用字节的长度
- NULL 值标识，如果该列有 NOT NULL 属性则可以没有这部分存储空间

如果该 VARCHAR 类型的列没有 NOT NULL 属性，那最多只能存储 65532 个字节的数据，因为真实数据的长度可能占用2个字节， NULL 值标识需要占用1个字节:

```
mysql> CREATE TABLE varchar_size_demo(
        ->      c VARCHAR(65532)
        -> ) CHARSET=ascii ROW_FORMAT=Compact;
    Query OK, 0 rows affected (0.02 sec)
```

如果 VARCHAR 类型的列有 NOT NULL 属性，那最多只能存储 65533 个字节的数据，因为真实数据的长度可能占用 2个字节，不需要 NULL 值标识

```
mysql> DROP TABLE varchar_size_demo;
    Query OK, 0 rows affected (0.01 sec)
mysql> CREATE TABLE varchar_size_demo(
        ->      c VARCHAR(65533) NOT NULL
        -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果 VARCHAR(M) 类型的列使用的不是 ascii 字符集，那 M 的最大取值取决于该字符集 表示一个字符最多需要的字节数。在列的值允许为 NULL 的情况下， gbk 字符集表示一个字符最多需要 2 个字 节，那在该字符集下， M 的最大取值就是 32766 (也就是:65532/2)，也就是说最多能存储 32766 个字符;

utf8 字符集表示一个字符最多需要 3 个字节，那在该字符集下， M 的最大取值就是 21844 ，就是说最多能存 储 21844 (也就是:65532/3)个字符

> 小贴士: 上述所言在列的值允许为NULL的情况下，gbk字符集下M的最大取值就是32766，utf8字符集下M的最大取 值就是21844，这都是在表中只有一个字段的情况下说的，一定要记住 **一个行中的所有列(不包括隐藏 列和记录头信息)占用的字节长度加起来不能超过65535个字节**

#### 记录中的数据太多产生的溢出

MySQL 中磁盘和内存交互的基本单位是 页 ，也就是说 MySQL 是以 页 为基本单位来管理存储空间的，我们 的记录都会被分配到某个 页 中存储。而一个页的大小一般是 16KB ，也就是 16384 字节，而一个 VARCHAR(M) 类 型的列就最多可以存储 65532 个字节，这样就可能造成一个页存放不了一条记录的尴尬情况



在 Compact 和 Reduntant 行格式中，对于占用存储空间非常大的列，在 记录的真实数据 处只会存储该列的一部 分数据，把剩余的数据分散存储在几个其他的页中，然后 记录的真实数据 处用20个字节存储指向这些页的地址 (当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数)，从而可以找到剩余数据所在的页

对于 Compact 和 Reduntant 行格式来说，如果某一列中的数据非常多的话，在本记录的真实 数据处只会存储该列的前 768 个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个 过程也叫做 行溢出 ，存储超出 768 字节的那些页面也被称为 溢出页 。画一个简图就是这样

<img src="pic/mysql是怎么运行的-笔记/image-20220307201728427.png" alt="image-20220307201728427" style="zoom:33%;" />

#### 行溢出的临界点

那发生 行溢出 的临界点是什么呢?也就是说在列存储多少字节的数据时就会发生 行溢出 ?

MySQL 中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影 响。以上边的 varchar_size_demo 表为例，它只有一个列 c ，我们往这个表中插入两条记录，每条记录最少插入 多少字节的数据才会 行溢出 的现象呢?这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要 136 个字节 的空间(现在只要知道这个数字就好了)，其他的空间都可以被用来存储记录。 
- 每个记录需要的额外信息是 27 字节。

这27个字节包括下边这些部分: 

- 2个字节用于存储真实数据的长度 
- 1个字节用于存储列是否是NULL值 
- 5个字节大小的头信息
- 6个字节的 row_id 列 
- 6个字节的 transaction_id 列 
- 7个字节的 roll_pointer 列

假设一个列中存储的数据字节数为n，那么发生 行溢出 现象时需要满足这个式子: 136 + 2×(27 + n) > 16384

求解这个式子得出的解是: n > 8098 。也就是说如果一个列中存储的数据不大于 8098 个字节，那就不会发生 行溢出 ，否则就会发生 行溢出 。不过这个 8098 个字节的结论只是针对只有一个列的 varchar_size_demo 表来

说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是:你不用关注这个临界点是什 么，只要知道如果我们想一个行中存储了很大的数据时，可能发生 行溢出 的现象

### **Dynamic**和**Compressed**行格式

下边要介绍另外两个行格式， Dynamic 和 Compressed 行格式，我现在使用的 MySQL 版本是 5.7 ，它的默认行格 式就是 Dynamic ，这俩行格式和 Compact 行格式挺像，只不过在处理 行溢出 数据时有点儿分歧，它们不会在记 录的真实数据处存储字段真实数据的前 768 个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数 据处存储其他页面的地址，就像这样

<img src="pic/mysql是怎么运行的-笔记/image-20220307202018455.png" alt="image-20220307202018455" style="zoom:33%;" />

Compressed 行格式和 Dynamic 不同的一点是， Compressed 行格式会采用压缩算法对页面进行压缩，以节省空 间。

## **InnoDB**数据页结构

数据页代表的这块 16KB 大小的存储空间可以被划分为多个部分，不同部分有不同的功能，各个部分如图所示:

<img src="pic/mysql是怎么运行的-笔记/image-20220307202351419.png" alt="image-20220307202351419" style="zoom:33%;" />

<img src="pic/mysql是怎么运行的-笔记/image-20220307202500054.png" alt="image-20220307202500054" style="zoom:35%;" />